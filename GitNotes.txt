* Дефиниция за version control

	Version control-a ни позволява да проследим промените, които сме правили на файл/ове и да възстановим този промени до някакаква произволна версия 
	
* Локални version control systems

	Локални version control systemи пазят историята на всички промени по дадени файлове,
	като позволяват връщане на произволна версия добавайки съответните промени 
	
* Централизирани version control systems

	Главен сървър съдържа цялата информация относно файловете и много клиенти използват сървъра за да теглят промените 
	
	Ако примерно се случи проблем със сървъра, може да се изгуби цялата информация, освен ако някой не си пази даден snapshot
	
* Разпределени Version Control systems

	DVCS позволява цялстно копиране на хранилището както и на неговата история с пачове 
	Тоест всяко копие дава на потребителя цялата история и всички файлове.
	Git работи по този начин 
	
* Как работи Git

	CVS пази промените като колекция от файлове, тоест да си качим една промяна трябва масово да си качиш файловете.
	
	Докато Git прави верижка от snapshot-ове, всеки shapshot пази единствено как изглежда файла, който си го променил и го запазва така,
	ако примерно не си променил даден файл тогава Git реферира към по-стар снапшот (тоест не го копираш наново)
	
	Ето това ти позволява докато използваш Git лесно да променяш между промените ти 
	
* Операциите на Git са локални 

	Понеже гит тегли цялостното хранилище, той тегли и историята на промените (различните снапшоти) и спокойно офлайн може да сравниш 
	дадени промени между файловете 
	
* Чексумите на Git 

	Всичко в Git се проследява чрез checksum-и, тоест Git вижда всичко и няма как да изпусне нещо
	Механизма който Git използва за checksum-ите се нарича SHA-1 и е низ от 40 стринга съдържащ 0-9 и a-f,
	генерира се базирано на съдържанието на файловете 
	
* Трите възможни състояния за Git 

	Когато работим в една директория, в която има repo, Git пази промените в 3 различни състояния:
	- modified (когато сме променили файл и не сме го дали за промяна)
	- staged (подаваме промяната която сме направили и тя би се качила в следващия commit)
	- commited (данните са записани в локалната база данни)
	
	Тоест имаме и 3 области на работа:
	- working directory // държи всички файлове върху който можем да работим 
	- staged directory  // промените който подлежат да бъдат комитнати 
	- repository  // git repository-то ни локалната база данни 
	
* Команди който използваме когато конфигурираме git 

	git config --global user.name "User Name"
	git config --global user.emal "useremail@email.com"
	
	--global го слагаме когато искаме подадената информация да важи за всички наши проекти 
	
	git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe'-multiInst -notabbar -nosession -noPlugin"
	Копи пейст това в терминала, кара git да ни отвори notepad++, когато искаме да пишем commit messageи
	
	git config --list показва всичките данни който са били конфигурирани 
	
	git config --global init.defaultBranch main // така променяме името на главния бранч, когато създаваме ново репо 
	
* Създаване на Git хранилище 

	Има два начина с който може да се сдобиш с git хранилище:
	- вече имаш съществуващ проект в директория и в неговата директория го създаваш това git repo 
	- теглиш вече създадено git repo от сървъра в избрана директория 
	
	Когато искаш да инициализираш репо, отиваш в дадена директория и пускаш командата:
	git init
	git init ти създава необходимите файлове и вече имаш готово репо 
	
	Когато искаш да клонираш (тоест да изтеглиш репо от сървъра) използваш:
	git clone <url>
	Тази команда ще ти направи цялостно копие на сървърната страна със история на всички промени.
	Ако репото което клонираш се казва myRepo в папката в която си извикал git clone ще ти създаде myRepo директория.
	Ако искаш тази директория да се казва по друг начин използвай това:
	git clone <url> myNewFolder 
	
* Запис на промените в хранилището 

	Всеки един файл в твоето хранилище може да бъде: tracked или untracked
	Tracked са тези файлове, който git познава, тоест от последния snapshot или вече stage-натите. Могат да бъдат modified, unmodified, stagged
	Untracked файловете са тези който не са в staging area-та или не са от последния snapshot 

	Примерно ако изтеглиш ново хранилище всички файлове ще бъдат tracked (защото  са от последния snapshot) и unmodified (защото не си ги променял)

* Проверка на статуса на файловете 

	Основната команда е git status, тя ти показва кой файлове са в staging area-та, кой са untracked, на кой бранч се намираш също
	
* Добавяне на нови файлове в staging area-та 

	Това става чрез командата: git add <името на файла>
	
	Това ще накара променен файл да бъде добавен в stading area-та.
	Ако примерно си забравил да добавиш нещо преди да комитнеш и правиш нови промени в файл-а който преди малко си преместил в staging area-та.
	Ще трябва отново да добавиш новите промени в staging area-a или иначе няма да се добавят в следващия commit.
	
* Игнориране на файлове 

	За да може Git да игнорира файлове, може да създадем файл с името .gitignore и в него да са написани кой extensions трябва да се игнорират:
	- За пример: *.тxt ще игнорира .txt файлове 
	
* Публикуване на промените 

	Става дума относно commit-ване, не забравяй само всичко което е в staging area-та ще бъде commit-вано, използвай командата:
	git commit
	
	Ако си написал git commit, ще ти се отвори текстовия редактор който си въвел с git config core.editor, за да напишеш комит съобщението
	
	Може да използваш git commit -m "Message" за да стане по-бързо 
	
	Когато комитнеш ще ти излязат:
	- колко файла си комитнал
	- към кой бранч си комитнал 
	- каква е чексумата 
	
	Можеш и да използваш git commit -a -m "Commit Message" директно да комитнеш modified файловете
	
* Изваждане на файла 

	Ако имаш файл file.txt, командата git rm file.txt ще:
	- изтрие самият файл 
	- ще stage-не тази промяна 
	
	Ако искаш да изтриеш file.txt в който има нови tracked промени, тогава използвай:
	git rm -f file.txt
	Или иначе ако използваш само git rm, няма да ти е позволено 
	
	
	Ако искаш да махнеш файла от staging area-та, но да остане на диска използвай:
	- git rm --chached file.txt 
	
* Преименуване на файл 

	Ако искаме да преименуваме вече съществуващ файл:
	git mv <oldName> <newName>
	
	Следната команда прави:
	- преименува самият файл в newName
	- премахва старият файл с git rm
	- добавя новия файл с git add 
	
	Пише че се добавя чрез git add и git rm, но Git вижда това като преименуване 
	
* Преглед на историята 

	Можем да прегледаме историята на комитите чрез git log, като най-новите промени са най-отгоре, показва ти и:
	- чексумата 
	- името на човека комитнал 
	- имейла му 
	- датата на комита 
	- и съобщението при комит 
	
	Ако използваш git log -p или git log --patch ще ти излезе както по горе описаната информация, така и самите промени в кода който са направени 
	при всеки комит 
	
	Обаче ако искаш да видиш по съкратена версия на промените в кода може да използваш git log --stat 
	
	Ако примерно не ти харесва самият структуриран текст може да използваш git log --pretty 
	Има и възможност да ти покаже граф и на снапшотите git log --graph 
	
	Запомни че авторът е различен от комитаджията
	Авторът е този който е променил файла, а комитаджията е този който е комитнал 
	
	Може да провериш последните 2 седмици какви комита са слагали чрез:
	git log --since=2.weeks
	
	Може да търсиш и чрез ключова дума -S между комиттите 
	git log -S function_name 
	
* Възстановяване на направени действия 

	git commit --amend ти позволява да промениш последния ти комит вместо да създаваш нов
	
	Прави следните неща:
	- Дава ти възможност да промениш комит съобщението 
	- Дава ти възможнсот да промениш/добавиш файлове към последния snapshot 
	
	Важно!!! git commit --amend ти пренаписва историята, тоест добра практика е да не го използваш за комити който вече са push-нати в споделеното
	хранилище
	
	Пример как да го използваш правилно:
	git commit -m "Initial commit"
	git add forgotten_file
	git commit --amend 
	
* Изваждане на файла от commit stage-a 

	Може да използваме git reset HEAD <fileName>
	
	Ако примерно си сложил два файла в staging are-a може да използваш горната команда, за да преместеш единия в working directory-то
	
* Отмяна на промените в променен файл 

	Ако си направил промени във файл, който още е в working directory-то и да му махнеш промените:
	git checkout -- <fileName>
	
	Това ще discard-не промените и ще ги изтрие, като върне <file> до съдържанието което е имало в последния комит 
	
* Възстановяване с git restore 

	git restore прави същите неща който git reset Head прави и git checkout -- също 
	
	Ако искаме да махнем даден файл, който сме променили от commit stage-a: git restore --staged <fileName>
	Ако искаме да махнем промените на даден файл, и да го върнем до състоянието му в последния комит: git restore <fileName>
	
* Работа с отдалечени хранилища 

	Отдалечените хранилища (remote branches) се намират в мрежата или сървъра откъдето теглиш проекта
	
	Може и да се използват и отдалеченените хранилище на текущият компютър на който работите,
	факта че пише отдалчено означава че се запазва някъде в Git 
	
	Използвай git remote, за да видиш отдалечените хранилища, който имаш конфигурирани на компютъра
	Ако си клонирал някое remote repo трябва да видиш поне origin - това е името което Git дава от сървъра от където си клонирал
	
	Чрез git remove -v може да видиш и самите remote repos къде сочат като url 
	
	
* Добавяне на remote repo 

	Понеже когато клонираш отдалечено репо, git дава името origin от Url на репото от което си дръпнал
	
	Ако искаш да добавиш ново repo от което да изтеглиш правиш с командата:
	git remote <shortname> <url>
	Shortname служи за псевдоним за url, просто може да използваш името вместо Url-a
	
	Ако после искаш да изтеглиш от самото repo новата информация правиш:
	git fetch <shortname>
	
* Fetching и Pulling на данни от repo-та 

	Командата която изтегля всички данни, който нямаме локално от remote repo:
	git fetch <remote>
	Командата също ще ти изтегли и бранчовете което има в това repo и ще можеш да си слееш промените локално 
	
	Когато git clonesh дадено репо, git автоматично ще създаде remote repo с името origin,
	тоест ако искаш да си актуализираш промените използвай git fetch origin 
	Не забравяй, че git fetch origin не ти слива автоматично промените, ти сам трябва да го направиш това 
	
	Обаче командата git pull автоматично ти тегли промените и автоматично ти ги слива с master branch-a 
	
* Изпращане на данни към отдалечено хранилище 

	Ако си имал промени в локалното си repo и искаш да го качиш в remote repo,то използвай: remote push <remote> <master>
	Пример remote push origin master (origin е url-a на repoto онлайн от което си теглил, а master ти е главния бранч)
	
	Ако примерно някой друг колега е сложил промени преди теб относно същата програма в която си работил,
	трябва първо неговите промени да изтеглиш, да ги слееш и след това да ги изтеглиш
	
* Преглед на отдалечено хранилище 

	За да провериш повече информация относно remote repo-тата използвай: git remote show <remote>
	
	Ще ти предостави информация относно:
	- Откъде fetch-ваш (url) и къде push-ваш (url)
	- Информация относно ти какви бранчове имаш
	- Информация относно remote branches (тоест другите branchove в remote repo-то)
	- Показва ти ако git pull-неш даден local branch от кой ще изтегли новата информация (ще бъде remote branch ) и ще слее промените 
	- Показва ти от кой local branch можеш да вкараш промени за да влязат в remote branch 
	
* Премахване и преименуване на отдалечените хранилища 

	За да преименуваш името на remote repo: git rename <oldName> <newName>
	Това също ще промени и пълните имена на бранчовете който са свързани към remote repo-то, тоест ще станат от <oldName>/<branchName> на <newName>/<branchName>
	
	За да премахнеш remote repo: git remote remove <repoName> 
	Това ще премахне всяка твоя локална промяна и локален бранч за remote repo-то 
	
* Тагове за версия в git 

	Можем да създаваме различни версии в различен етап на разработката ни в Git
	
	Можеш да видиш текъщите версии с: git tag 
	Можеш даже да видиш и тага по определен стринг: git tag -l "1.2.4*"
	
	Има два основни типа тагове: lightweight и annotated.
	
	Lightweight сочи към даден комит 
	Annotated отновно сочи като lightweight към даден комит, но този път има повече информация към тага като имейл, име на човека който е направил tag-a
	и описателно съобщение 
	
	За да направим annotated tag използваме: git tag -a <version> -m "Message initial", ще ти излезе текстов редактор за да си напишеш комит съобщението 
	После може да използваш git show <tagVersion>, за да ти покаже по-подробна информация за тага 
	
	За да създадеш lightweight комит: git tag <versionVersion> единствената информация която пази този таг е чексумата на камита който е записан във файла 
	Ако искаш да видиш lightweight тага с git show ще ти излезе само комита към който сочи 
	
	Ако си изпуснал да направиш даден комит на таг можеш спокойно да се върнеш като използваш чексумата на комита който искаш да е версията:
	git tag -a <versionName> <checksum>
	
	Когато създадеш един таг, той не се push сам, а ти трябва да го направиш ръчно:
	git push origin <tagName> 
	Ако имаш много тагове и искаш наведнъж да ги направиш даваш: git push origin --tags
	
	Ако искаш да изтриеш таг от локалното си хранилище ще трябва да използваш: git tag -d <tagName>, обаче това няма да го изтрие от remote repo-то
	За да изтриеш даден таг от remote repo трябва да използваш git push origin --delete <tagName>, един вид буташ промяната, че този таг го триеш 
	
	Можеш да се върнеш към стар таг чрез git checkout <tag>, но трябва да си внимателен, но трябва да си внимателен защото ще влезеш в DETACHED HEAD състояние
	Тоест вместо да сочиш към master brancha, ти сочиш към нищо и ако комитнеш нещо сега ще са ти загубени промените.
	Най-safe е да създадеш нов бранч от този таг и да го merge-неш с master: git checkout -b <branchname> <tagname>
	
* Псевдоними 

	Позволява ти да можеш да съкратиш командите който пишеш често и да имаш свой псевдоним за няколко команди наведнъж
	git config --global alias.st status, сега вместо git status може да напишеш git st
	git config --global alias.unstage 'reset HEAD --', ако напишеш git unstage ще ти изпълни git reset HEAD -- командата 
	
* Branching като цяло 

	Branching означава, че се отделяме от главния branch и промените който правим, не се прилагат върху главния бранч на момента 
	
	В повчето vc системи си принуден да копираш цялата директория на файловете който искаш да промениш
	и това отнема много ресурси 
	
	Не забравяй, че Git не пази точно разликите който си направил между комитите, а когато комитнеш Git прави снимка на сегашното положение на файла,
	а и после между комитите се сравнява състоянията на файловете и така ти показва разликите 
	
	Тоест когато комитнеш Git прави един commit обект, който съдържа:
	- snapshot-a на файловете който са били в staging area-та 
	- името на автора
	- комит съобщението 
	- указател, който сочи към предишният комит 
	
	Първоначалния комит няма родители, един нормален комит има само един родител, ако имаш комит който е резултат от merge тогава имаш няколко родители 
	
	Първоначалния комит на едно репо винаги се казва master/main, който винаги сочи към най-последния ти комит (Това, че се казва master не го прави по-специален)

* Създаване на нов branch 

	Правене на бранч става с тази команда: git branch testing 
	Новият бранч testing ще сочи към комита който си направил в момента (тоест на сегашното състояние)
	
	HEAD е главния указател и той сочи към най-последния комит който си правил, в момента на създаването на brach testing,
	HEAD сочи към master, това е така, защото не си превключил на testing 
	
	Чрез git log --decorate може да видиш и HEAD към кой бранч сочи
	
* Превключване към бранч 

	За да се превключиш на друг клон използваш git checkout <branchName>
	С други думи местиш самият HEAD указател 
	
	Ако искаш да превключиш на бранча testing и комитнеш нещо към него HEAD ще сочи на един комит напред, защото master бранча още не е пипан.
	Ако ти решиш да git checkout master без да запазиш файловете от предишния комит в testing, той ще бъде премахнат и HEAD отново ще сочи към master.
	
	Когато искаш да видиш истроията на комитите използвай git log -all или git log <branchname>
	
	Може и да използваш: graph log --oneline --decorate --graph --all
	
	Ако искаш да направиш бранч и веднага да се прехвърлиш на него git checkout -b <branchName>
	
* Реален пример, който може да ти се случи докато работиш

	1. Създал си си бранч от master branch-a и разработваш нов feature 
	2. Сложил си няколко комита в този твоя бранч 
	
	Възможно е по някое време да ти кажат че трябва да работиш по друг проблем
	
	1. връщаш се обратно на master brancha 
	2. създаваш си нов brach Който да оправиш нововъзникналия проблем 
	3. чакаш да се слее hotfix-a в продуктовия код (master)
	4. продължаваш да си работиш на бранча за новия feature 
	
	
	
	
	
	
	
	