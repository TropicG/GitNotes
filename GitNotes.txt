* Дефиниция за version control

	Version control-a ни позволява да проследим промените, които сме правили на файл/ове и да възстановим този промени до някакаква произволна версия 
	
* Локални version control systems

	Локални version control systemи пазят историята на всички промени по дадени файлове,
	като позволяват връщане на произволна версия добавайки съответните промени 
	
* Централизирани version control systems

	Главен сървър съдържа цялата информация относно файловете и много клиенти използват сървъра за да теглят промените 
	
	Ако примерно се случи проблем със сървъра, може да се изгуби цялата информация, освен ако някой не си пази даден snapshot
	
* Разпределени Version Control systems

	DVCS позволява цялстно копиране на хранилището както и на неговата история с пачове 
	Тоест всяко копие дава на потребителя цялата история и всички файлове.
	Git работи по този начин 
	
* Как работи Git

	CVS пази промените като колекция от файлове, тоест да си качим една промяна трябва масово да си качиш файловете.
	
	Докато Git прави верижка от snapshot-ове, всеки shapshot пази единствено как изглежда файла, който си го променил и го запазва така,
	ако примерно не си променил даден файл тогава Git реферира към по-стар снапшот (тоест не го копираш наново)
	
	Ето това ти позволява докато използваш Git лесно да променяш между промените ти 
	
* Операциите на Git са локални 

	Понеже гит тегли цялостното хранилище, той тегли и историята на промените (различните снапшоти) и спокойно офлайн може да сравниш 
	дадени промени между файловете 
	
* Чексумите на Git 

	Всичко в Git се проследява чрез checksum-и, тоест Git вижда всичко и няма как да изпусне нещо
	Механизма който Git използва за checksum-ите се нарича SHA-1 и е низ от 40 стринга съдържащ 0-9 и a-f,
	генерира се базирано на съдържанието на файловете 
	
* Трите възможни състояния за Git 

	Когато работим в една директория, в която има repo, Git пази промените в 3 различни състояния:
	- modified (когато сме променили файл и не сме го дали за промяна)
	- staged (подаваме промяната която сме направили и тя би се качила в следващия commit)
	- commited (данните са записани в локалната база данни)
	
	Тоест имаме и 3 области на работа:
	- working directory // държи всички файлове върху който можем да работим 
	- staged directory  // промените който подлежат да бъдат комитнати 
	- repository  // git repository-то ни локалната база данни 
	
* Команди който използваме когато конфигурираме git 

	git config --global user.name "User Name"
	git config --global user.emal "useremail@email.com"
	
	--global го слагаме когато искаме подадената информация да важи за всички наши проекти 
	
	git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe'-multiInst -notabbar -nosession -noPlugin"
	Копи пейст това в терминала, кара git да ни отвори notepad++, когато искаме да пишем commit messageи
	
	git config --list показва всичките данни който са били конфигурирани 
	
	git config --global init.defaultBranch main // така променяме името на главния бранч, когато създаваме ново репо 
	
* Създаване на Git хранилище 

	Има два начина с който може да се сдобиш с git хранилище:
	- вече имаш съществуващ проект в директория и в неговата директория го създаваш това git repo 
	- теглиш вече създадено git repo от сървъра в избрана директория 
	
	Когато искаш да инициализираш репо, отиваш в дадена директория и пускаш командата:
	git init
	git init ти създава необходимите файлове и вече имаш готово репо 
	
	Когато искаш да клонираш (тоест да изтеглиш репо от сървъра) използваш:
	git clone <url>
	Тази команда ще ти направи цялостно копие на сървърната страна със история на всички промени.
	Ако репото което клонираш се казва myRepo в папката в която си извикал git clone ще ти създаде myRepo директория.
	Ако искаш тази директория да се казва по друг начин използвай това:
	git clone <url> myNewFolder 
	
* Запис на промените в хранилището 

	Всеки един файл в твоето хранилище може да бъде: tracked или untracked
	Tracked са тези файлове, който git познава, тоест от последния snapshot или вече stage-натите. Могат да бъдат modified, unmodified, stagged
	Untracked файловете са тези който не са в staging area-та или не са от последния snapshot 

	Примерно ако изтеглиш ново хранилище всички файлове ще бъдат tracked (защото  са от последния snapshot) и unmodified (защото не си ги променял)

* Проверка на статуса на файловете 

	Основната команда е git status, тя ти показва кой файлове са в staging area-та, кой са untracked, на кой бранч се намираш също
	
* Добавяне на нови файлове в staging area-та 

	Това става чрез командата: git add <името на файла>
	
	Това ще накара променен файл да бъде добавен в stading area-та.
	Ако примерно си забравил да добавиш нещо преди да комитнеш и правиш нови промени в файл-а който преди малко си преместил в staging area-та.
	Ще трябва отново да добавиш новите промени в staging area-a или иначе няма да се добавят в следващия commit.
	
* Игнориране на файлове 

	За да може Git да игнорира файлове, може да създадем файл с името .gitignore и в него да са написани кой extensions трябва да се игнорират:
	- За пример: *.тxt ще игнорира .txt файлове 
	
* Публикуване на промените 

	Става дума относно commit-ване, не забравяй само всичко което е в staging area-та ще бъде commit-вано, използвай командата:
	git commit
	
	Ако си написал git commit, ще ти се отвори текстовия редактор който си въвел с git config core.editor, за да напишеш комит съобщението
	
	Може да използваш git commit -m "Message" за да стане по-бързо 
	
	Когато комитнеш ще ти излязат:
	- колко файла си комитнал
	- към кой бранч си комитнал 
	- каква е чексумата 
	
	Можеш и да използваш git commit -a -m "Commit Message" директно да комитнеш modified файловете
	
* Изваждане на файла 

	Ако имаш файл file.txt, командата git rm file.txt ще:
	- изтрие самият файл 
	- ще stage-не тази промяна 
	
	Ако искаш да изтриеш file.txt в който има нови tracked промени, тогава използвай:
	git rm -f file.txt
	Или иначе ако използваш само git rm, няма да ти е позволено 
	
	
	Ако искаш да махнеш файла от staging area-та, но да остане на диска използвай:
	- git rm --chached file.txt 
	
* Преименуване на файл 

	Ако искаме да преименуваме вече съществуващ файл:
	git mv <oldName> <newName>
	
	Следната команда прави:
	- преименува самият файл в newName
	- премахва старият файл с git rm
	- добавя новия файл с git add 
	
	Пише че се добавя чрез git add и git rm, но Git вижда това като преименуване 
	
* Преглед на историята 

	Можем да прегледаме историята на комитите чрез git log, като най-новите промени са най-отгоре, показва ти и:
	- чексумата 
	- името на човека комитнал 
	- имейла му 
	- датата на комита 
	- и съобщението при комит 
	
	Ако използваш git log -p или git log --patch ще ти излезе както по горе описаната информация, така и самите промени в кода който са направени 
	при всеки комит 
	
	Обаче ако искаш да видиш по съкратена версия на промените в кода може да използваш git log --stat 
	
	Ако примерно не ти харесва самият структуриран текст може да използваш git log --pretty 
	Има и възможност да ти покаже граф и на снапшотите git log --graph 
	
	Запомни че авторът е различен от комитаджията
	Авторът е този който е променил файла, а комитаджията е този който е комитнал 
	
	Може да провериш последните 2 седмици какви комита са слагали чрез:
	git log --since=2.weeks
	
	Може да търсиш и чрез ключова дума -S между комиттите 
	git log -S function_name 
	
* Възстановяване на направени действия 

	git commit --amend ти позволява да промениш последния ти комит вместо да създаваш нов
	
	Прави следните неща:
	- Дава ти възможност да промениш комит съобщението 
	- Дава ти възможнсот да промениш/добавиш файлове към последния snapshot 
	
	Важно!!! git commit --amend ти пренаписва историята, тоест добра практика е да не го използваш за комити който вече са push-нати в споделеното
	хранилище
	
	Пример как да го използваш правилно:
	git commit -m "Initial commit"
	git add forgotten_file
	git commit --amend 
	
* Изваждане на файла от commit stage-a 

	Може да използваме git reset HEAD <fileName>
	
	Ако примерно си сложил два файла в staging are-a може да използваш горната команда, за да преместеш единия в working directory-то
	
* Отмяна на промените в променен файл 

	